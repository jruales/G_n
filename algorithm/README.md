# README
Here's roughly how to use the program:

First, add all the "identities" you know or have derived to the file `identities.txt`. Each identity should occupy a line. Blank lines an lines preceded by double slash ("//") are ignored by the program. You can also ignore a whole block by surrounding it with "/*" and "*/". Each identity consists of a sequence of lowercase and uppercase letters, where the uppercase letters represent the inverse of the lowercase counterparts. There's no need to include all the rotations or even the inverse of a particular identity.
For example, if you include `AdAbCb`, you don't need to also include e.g. `bCbAdA`, or `BcBaDa`.

Second, add all elements that you know for certain are positive into the file `posCone.txt`. These could have been derived by hand, found through a previous run of the program, or even based on a case split like we did on the paper. This file has the same format as `identities.txt`.

At the start, the program creates connections between the elements in the positive elements list indicating if any components would cancel out when multiplying the two element together (e.g. `AaBB * bbC = AaC`, so we record that two elements would cancel out when `AaBB` is multiplied by `bbC`). These connections will later be used when checking for contradictions. For example, if `AaC` is marked as an identity and `AaBB` and `bbC` are marked as being positive, we will be able to recognize that this "identity" is actually a combination of things in the positive cone, reaching a contradiction.

The program tries to find two types of contradictions:

1. Cone contradictions, where given a set of items that are supposed to be positive, we end up concluding that an element is both positive and negative. e.g. if we say that both `aaB`, `bA` and `A` are all positive, we combine the first two into `a`, which should also be positive, but now we're saying that both `A` and `a` are positive. Within the program, we check for this type of contradiction by using the `theresAConetradiction()` function.
2. Identity contradictions, where we determine that one of the 'identities' is actually positive. e.g. if our list of identities contains the element `abCD` and our list of positive elements contains `bCDa`, we see that we can 'rotate' the identity element (which should preserve sign) into being positive, thus reaching a contradiction. We check for this type of contradiction by using the function `stringSign()` in the program. Note that this function uses the `visited` boolean 3D array for optimization, so don't call it directly until you're familiar with how this is used.

In addition to this functionality, the program has several modes of operation. These are defined at the start of the program by the String `inputType`.
* `"none"` simply checks for Cone Contradictions and Identity Contradictions within the identities in `identities.txt` and the positive elements in `posCone.txt`. Use this mode if you're checking the integrity of your list of positive elements and identities.
* `"brute"` mode might be the best mode to try at the start. It runs the same code as `"none"` mode, and then tries a brute-force approach: it temporarily adds an element to the positive cone and sees if it causes any of the contradictions mentioned above. If it doesn't, and if the program determines that it's positive, the program keeps it in the positive elements list and prints it out (Note: the program doesn't write into `posCone.txt`, so adding any elements there should be done manually based on the program's output if you'd like to include them in the positive cone for a future run). Otherwise it removes it from there and checks the next element. When trying the brute force approach, all possible elements are tried starting from length 1 elements, then length 2, etc. If you'd like to start with length-k elements instead, uncomment k of those `enlargeBruteList()` calls.
* `"user"` mode is similar to `"brute"` mode, but instead of automatically choosing the elements to try to add to the positive cone automatically, it prompts the user to input them into the program. You can input up to 10 elements at a time, and it will try adding all possible combination of the elements and their inverses to the positive cone to check for contradictions. You'll need to uncomment some lines of code under `if (inputType.equals("user")) {` in order to get this mode to work.
* `"pairwise"` mode is like `"user"` mode, except that it tries elements from the file `missingCases.txt` instead of prompting the user for them every time the program runs. This mode always checks two elements at a time (not up to 10 elements like "user" mode can do), all possible pairs of elements in `missingCases.txt`, hence the name "pairwise". If you'd like to try one element at a time from `missingCases.txt`, I think you this is the functionality on `"brute"` mode when bruteList is empty (not even with an empty string) and you've never called `enlargeBruteList()`.
